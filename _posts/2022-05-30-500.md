---
layout: post
title: "500"
date: 2022-05-30 00:00:00 -700
categories: Blog
---

<div class="blog-content">
				<div class="paragraph"><span><span>This will be a short one. I&rsquo;m really just here to praise the graphical Swiss army knife that is Blender.</span></span><br><span><span>So, a little bit ago, I was working on some textures. The task was to pack a non-alpha grayscale image into the alpha channel. Non-alpha, in that it wouldn&rsquo;t be used as transparency data for the image. I figured that a channel was a channel so how hard could it be.&nbsp;</span></span><br><span><span>I&rsquo;ll back up slightly.</span></span><br><span><span>Sometimes, when working with textures, especially for realtime 3d applications like games, you want to pack as much information as you can into each texture. Standard image files are made up of three or four channels. The Red, Green, Blue, and sometimes Alpha channels. Usually, each channel is a grayscale image that represents&nbsp; steps from black to white, the contribution of each channel's pixels to the final image. If one pixel of the green channel is one hundred percent white, then the green contribution to that pixel will be turned up as high as it can be.&nbsp;</span></span><br><span><span>Now there are a lot of perceptual issues that mean that some images have higher contributions from some channels, or they apply different falloff curves to different parts of the color spectrum, for simplicity&rsquo;s sake, let's just say that each channel has a full range of 128 or 256 steps between black and white for each pixel.</span></span><br><span><span>There is nothing saying that you need to use those grayscale channels to build up parts of the same image. What if you have three, entirely different, grayscale images. Rather than using up all three channels of one texture, why not pack all of those into a single texture file using the R, G, and B channels. If you have a fourth one, you can pack that into the alpha channel. At least that&rsquo;s what I thought.</span></span><br><span><span>Channel packing using the R, G, and B channels is pretty trivial, and pretty much any image editor will let you do that. Packing stuff into the Alpha channel proved to be a bit more difficult.&nbsp;</span></span><br><span><span>The Alpha channel is usually used for transparency. Same rules apply, though. It is a grayscale image that controls how transparent or opaque each pixel is. The problems happen when you make a pixel 100% transparent.</span></span><br><span><span>Most image editors are pretty smart. They will try to infer what you are trying to do. If you convert an image from say, RGB color format to CMYK for printers, there is a set of steps and conversions that the image editor will go through to try to keep the colors as accurate to what you intended as possible. The same thing happens when you set a pixel in the alpha channel all the way to transparent. Most image editors will set that same pixel in the R, G, and B channels to zero as well. It makes sense when you think about it. If you are saving that image out with a bunch of zeros, data compression schemes can shrink the file quite a bit. Only problem is, when you are trying to do channel packing, you don&rsquo;t want to lose that information.</span></span><br><span><span>Now, not all image editors did this. Some kept all the info, but had other issues. They couldn&rsquo;t read the input images properly, or they couldn&rsquo;t create an output image properly. They didn&rsquo;t work with the formats I needed, or they lacked support for linear color space (sort of a must for some texture work).</span></span><br><span><span>After trying all the standard image editing tools I have, and it&rsquo;s not an exaggeration to say that I have an awful lot, I found that only Blender did everything that I needed. Not only that, but it did it better and easier than any of the others.&nbsp;</span></span><br><span><span>I will qualify that &lsquo;easier&rsquo;. Blender can look like the control panel of a 747 and it has functions buried under its function, but if you happen to know how it works, you can mix and match and mess with images in a truly unrestrained way.</span></span><br><span><span>I used the compositing part of Blender. It&rsquo;s intended to be used to layer rendered or filmed images, blending them and adjusting them until they look seamless. It&rsquo;s the sort of software used to piece together visual effects sequences in movies. Because of that raw image manipulating power, it&rsquo;s also uniquely suited to ripping apart and reassembling textures in the most amazing ways.</span></span><br><span><span>I created a pipeline that split all of the channels and then recombined them in any way that I liked, and any set of images that I used as the input could be run through the system and recombined. Not only that, but Blender works with damn near any image format that you could imagine, and it&rsquo;s all hardware accelerated. I could rip apart massive 5K textures and put them back together into uncompromising .EXR files (without a doubt, the best image format that people have come up with), in literal seconds.</span></span><br><span><span>I don&rsquo;t know that a tutorial on how to do it is exactly warranted here, but this is a picture of the node tree that the textures run through.</span></span><br><span><span>Blender is really one of the best things to happen to graphics in a very long time.</span></span><br></div>  <div><div class="wsite-image wsite-image-border-none " style="padding-top:10px;padding-bottom:10px;margin-left:0;margin-right:0;text-align:center"> <a> <img src="/uploads/texturepack_orig.png" alt="Picture" style="width:auto;max-width:100%"> </a> <div style="display:block;font-size:90%"></div> </div></div>

		</div>
        